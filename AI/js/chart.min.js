/*!
 * Chart.js v3.7.0 (Simplified version)
 * https://www.chartjs.org
 * Released under the MIT License
 */
(function(global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Chart = factory());
})(this, (function() {
  'use strict';
  
  // 简化版Chart.js核心功能
  class Chart {
    constructor(ctx, config) {
      this.ctx = ctx;
      this.canvas = ctx.canvas;
      this.config = config;
      this.data = config.data || {};
      this.options = config.options || {};
      this.type = config.type;
      
      this.render();
    }
    
    render() {
      const ctx = this.ctx;
      const canvas = this.canvas;
      const width = canvas.width;
      const height = canvas.height;
      
      // 清除画布
      ctx.clearRect(0, 0, width, height);
      
      // 根据图表类型绘制
      switch(this.type) {
        case 'line':
          this.drawLine();
          break;
        case 'bar':
          this.drawBar();
          break;
        case 'pie':
        case 'doughnut':
          this.drawPie();
          break;
        default:
          console.error('Unsupported chart type');
      }
      
      // 绘制图例
      if (this.options.plugins && this.options.plugins.legend && this.options.plugins.legend.display !== false) {
        this.drawLegend();
      }
    }
    
    drawLine() {
      const ctx = this.ctx;
      const canvas = this.canvas;
      const width = canvas.width;
      const height = canvas.height;
      const datasets = this.data.datasets || [];
      const labels = this.data.labels || [];
      
      // 简单的线图实现
      const padding = 40;
      const chartWidth = width - padding * 2;
      const chartHeight = height - padding * 2;
      
      // 绘制坐标轴
      ctx.beginPath();
      ctx.moveTo(padding, padding);
      ctx.lineTo(padding, height - padding);
      ctx.lineTo(width - padding, height - padding);
      ctx.stroke();
      
      // 绘制数据线
      datasets.forEach((dataset, i) => {
        const data = dataset.data || [];
        
        // 找出数据最大值用于缩放
        const max = Math.max(...data);
        
        ctx.beginPath();
        ctx.strokeStyle = dataset.borderColor || '#000';
        ctx.fillStyle = dataset.backgroundColor || 'rgba(0,0,0,0.1)';
        
        // 绘制线条
        data.forEach((value, j) => {
          const x = padding + (chartWidth / (data.length - 1)) * j;
          const y = height - padding - (value / max) * chartHeight;
          
          if (j === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        });
        
        ctx.stroke();
        
        // 如果需要填充
        if (dataset.fill) {
          ctx.lineTo(padding + chartWidth, height - padding);
          ctx.lineTo(padding, height - padding);
          ctx.fill();
        }
      });
    }
    
    drawBar() {
      const ctx = this.ctx;
      const canvas = this.canvas;
      const width = canvas.width;
      const height = canvas.height;
      const datasets = this.data.datasets || [];
      const labels = this.data.labels || [];
      
      // 简单的柱状图实现
      const padding = 40;
      const chartWidth = width - padding * 2;
      const chartHeight = height - padding * 2;
      
      // 绘制坐标轴
      ctx.beginPath();
      ctx.moveTo(padding, padding);
      ctx.lineTo(padding, height - padding);
      ctx.lineTo(width - padding, height - padding);
      ctx.stroke();
      
      // 绘制柱状
      datasets.forEach((dataset) => {
        const data = dataset.data || [];
        
        // 找出数据最大值用于缩放
        const max = Math.max(...data);
        
        // 计算柱宽
        const barWidth = chartWidth / data.length * 0.8;
        const barSpacing = chartWidth / data.length * 0.2;
        
        ctx.fillStyle = dataset.backgroundColor || '#000';
        
        // 绘制每个柱
        data.forEach((value, j) => {
          const x = padding + (chartWidth / data.length) * j + barSpacing / 2;
          const barHeight = (value / max) * chartHeight;
          const y = height - padding - barHeight;
          
          ctx.fillRect(x, y, barWidth, barHeight);
        });
      });
    }
    
    drawPie() {
      const ctx = this.ctx;
      const canvas = this.canvas;
      const width = canvas.width;
      const height = canvas.height;
      const datasets = this.data.datasets || [];
      const labels = this.data.labels || [];
      
      // 简单的饼图/环形图实现
      const centerX = width / 2;
      const centerY = height / 2;
      const radius = Math.min(width, height) / 2 - 40;
      
      const dataset = datasets[0] || {data: []};
      const data = dataset.data || [];
      const colors = dataset.backgroundColor || [];
      
      // 计算总和
      const total = data.reduce((sum, value) => sum + value, 0);
      
      // 绘制饼图
      let startAngle = 0;
      
      data.forEach((value, i) => {
        const sliceAngle = 2 * Math.PI * value / total;
        
        ctx.beginPath();
        ctx.fillStyle = Array.isArray(colors) ? colors[i % colors.length] : colors;
        ctx.moveTo(centerX, centerY);
        ctx.arc(centerX, centerY, radius, startAngle, startAngle + sliceAngle);
        ctx.closePath();
        ctx.fill();
        
        // 如果是环形图，绘制中心空白
        if (this.type === 'doughnut') {
          ctx.beginPath();
          ctx.fillStyle = '#fff';
          ctx.moveTo(centerX, centerY);
          ctx.arc(centerX, centerY, radius * 0.5, 0, 2 * Math.PI);
          ctx.closePath();
          ctx.fill();
        }
        
        startAngle += sliceAngle;
      });
    }
    
    drawLegend() {
      const ctx = this.ctx;
      const canvas = this.canvas;
      const width = canvas.width;
      const height = canvas.height;
      const datasets = this.data.datasets || [];
      const labels = this.data.labels || [];
      
      // 简单的图例实现
      const legendY = height - 20;
      const itemWidth = width / labels.length;
      
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      labels.forEach((label, i) => {
        const x = itemWidth * (i + 0.5);
        
        // 绘制图例颜色块
        ctx.fillStyle = datasets[0].backgroundColor[i] || '#000';
        ctx.fillRect(x - 30, legendY, 10, 10);
        
        // 绘制图例文字
        ctx.fillStyle = '#000';
        ctx.fillText(label, x, legendY);
      });
    }
    
    update() {
      this.render();
    }
  }
  
  return Chart;
}));